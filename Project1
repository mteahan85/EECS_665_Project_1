#lang plai
(require racket/trace)

#! -----------------------------------------------------------------------------
#! -----------------------------------------------------------------------------
#! --------------------  BEGIN PARSER/STRUCTURE CREATION    --------------------
#! -----------------------------------------------------------------------------
#! -----------------------------------------------------------------------------

 #! Pass in file which stores NFA information. Will build structure for NFA information                             
 (define parser
   (lambda (file)
     (strings-to-list (file->lines file))
     )
   )

#! Takes the list of strings/lines from the file and breaks down those strings into list of elements in the string => a list of lists
(define strings-to-list
  (lambda (list_of_file)
    (create-structure (foldr structure-for-info '() (take (map string-split list_of_file) 4))  (map string-split list_of_file))
    )
  )

#! Creates a structure with NFA information
#! stores Initial, Total, etc.. at front and states further down as an associative list
(define create-structure 
  (lambda (info_structure input)
    (cons info_structure (structure-for-states info_structure (cddddr input)))
    )
  )

#! Creates the associative list structure for the states of the NFA
(define structure-for-states
  (lambda (info input)
    (foldr (lambda (lines nfa) 
             (cons (cons (string->number (car lines)) (list (match-moves (cdr lines) (cadr (assoc 'alpha info)))))  nfa))
             
           '() input)
    )
  )
  
#! Takes alphabet and matches it with each move
#! Practice with: (match-moves '("{2,3}" "{}" "{3}") '('a 'b 'c))
(define match-moves
  (lambda (line alpha)
    (if (empty? alpha) '()
        (cons (cons (car alpha) (convert-moves (car line))) (match-moves (cdr line) (cdr alpha)))
        )
    )
  )
  
#! Converts string of moves into multiple strings/move items
(define convert-moves
  (lambda (moves)
    (list (moves-to-symbol (string-split (substring moves 1 (- (string-length moves) 1)) ",")))
    )
  )

#! Converts individual strings into symbols
(define moves-to-symbol
  (lambda (moves)
    (if (empty? moves) '()
        (cons (string->number (car moves)) (moves-to-symbol (cdr moves)))
        )
    )
  )

#! Creates associative list structure for NFA Info
(define structure-for-info
  (lambda (lines nfa)
    (case (car lines)
      (("Initial") (cons (list 'initial (car (convert-info (last lines)))) nfa))
      (("Final") (cons (list 'final (convert-info (last lines))) nfa))
      (("Total") (cons (list 'total (string->number (last lines))) nfa))
      (("State") (cons (list 'alpha (convert-alpha (cdr lines))) nfa))
      )
    )
  )

#! Converts list of Alphabet strings into list of symbols
(define convert-alpha
  (lambda (alphabet)
    (if (empty? alphabet) '()
        (cons (string->symbol (car alphabet)) (convert-alpha (cdr alphabet)))
        )
    )
  )

#! Converts string of info into actual symbol list
(define convert-info
  (lambda (line)
    (foldr get-nums '() (string-split (substring line 1 (- (string-length line) 1)) ","))
    )
  )

#! Converst string of a number into a symbol
(define get-nums
  (lambda (input nums)
    (cons (string->number input) nums))
      )

#! -----------------------------------------------------------------------------
#! -----------------------------------------------------------------------------
#! --------------------  END PARSER/STRUCTURE CREATION      --------------------
#! -----------------------------------------------------------------------------
#! -----------------------------------------------------------------------------

#! -----------------------------------------------------------------------------
#! -----------------------------------------------------------------------------
#! --------------------  BEGIN NFA to DFA CONVERSION        --------------------
#! -----------------------------------------------------------------------------
#! -----------------------------------------------------------------------------


(define start-conversion
  (lambda (file)
    (let ([nfa (parser file)])
      (convert nfa '() (list (e-closure nfa (find-initial-state nfa))) '())
      )
  )
  )

(define convert
  (lambda (nfa dfa stack set_dict)
   (if(empty? stack)  ; check, is stack empty? empty means, stack = '(), if so, return dfa that has been made pretty, else mark top of stack
         (transform-dfa nfa dfa set_dict)
    (let ([marked_moves (mark nfa (car stack))]) ;turn into a queue and move down it
      (let ([add_marks (add-marks-to-dict marked_moves set_dict)])
         (convert
               nfa
               (append dfa (list (cons (car stack) (list marked_moves))))
               (update-queue stack add_marks) ;add new items to the queue while taking the item you just marked off
               (append set_dict (generate-marks add_marks))
               ; stack -> (pop stack), concat new sets retrieved rom marked_moves ("new" means, not in set_dict) -> if a on stack, pop a, mark a get b c from marking, push list on stack
               ; set_dict -> new sets retrieved from marked_moves   
            )
        )
      )
    )
    )
  )
  
;need to think of way to check if not in dictionary and if not add to dictinary and to stack


#! Finds the initial state of the NFA
(define find-initial-state
  (lambda (nfa)
    (cdr (assoc 'initial (car nfa)))
    )
  )

#! Reorganizes Queue for Stack - pops the top and queues others to back 
;Must recieve list of lists '( () () )
(define update-queue
  (lambda (stack queue)
    (append (cdr stack) queue)
    )
  )
     


#! Creates a list of moves not found in the set_dict
;takes in list of lists '( () () )
;returns list of lists '( () () )
(define add-marks-to-dict
  (lambda (moves set)
    (foldr (lambda (move l)
             (if (not-in-dict move set)
                 (cons  (caadr move) l)
                 l
                 )
             ) '() moves)
             
    )
  )

#! Generates a key-value pair for each mark to be appeneded to the set_dict
;takes a list of lists '( () () ) returns list of pairs
;'((4 8 9 11) (5 6 7 11))
; =====>
;'(((4 8 9 11) . #<procedure:gensym>) ((5 6 7 11) . #<procedure:gensym>))
(define generate-marks
  (lambda (marks)
    (map (lambda (mark)
           (cons mark (gensym))
           ) marks)
    )
  )



#! Mark is not already in dictoinary

 (define not-in-dict
   (lambda (move set)
     (andmap (lambda (set_item)
               (not (compare-lists (caadr move) (car set_item))) ;(given as '() . procdedure) need to fix
               )
             set)
     )
   )
      
  
(define transform-dfa
  (lambda (nfa dfa set_dict)
    (append (car nfa) dfa )
    )
  )

  


#! Marks the sets
; takes in a list of numbers '(2 3 4)
;
(define mark
  (lambda (nfa set)
    (foldr (lambda (alpha marking) 
             (let ([moves (get-moves set nfa alpha)])
                    (cons (list alpha (cons (e-closure nfa moves) (list moves))) marking)
             )
             )
           '() (remove 'E (cadr (assoc 'alpha (car nfa))))
           )
    )
  )
     
#! Get E-Closure moves
(define e-closure
  (lambda (nfa set)
    (let ([e (append set (get-moves set nfa 'E))])
    (if(compare-lists set (remove-duplicates e))
       (sort set <)
       (e-closure nfa (remove-duplicates e))
       )
    )
    )
  )
     

#! Get all moves for states at particular alphabet letter
(define get-moves
  (lambda (state_list nfa alpha)
    (remove-duplicates (foldr (lambda (state output)
             (foldr (lambda (state out)
                        (cons state out)
                         )
                      output (cadr (assoc alpha (cadr (assoc state nfa))))
                      )
                    
             )
             '() state_list)
    ))
  )

#! Checks to make sure state doesn't exist in list of moves
(define not-in-list 
  (lambda (state list)
    (andmap (lambda (l)
              (if (= state l)
                  false
                  true
                  )
              ) list
            )
    )
  )



#! Checks to Mark in Table -- returns 0, if it doesn't exist
(define check-e-closure
  (lambda (closure table)
    (if(empty? table)  0
    (if (compare-lists closure (cadar table))
        (caar table)
        (check-e-closure closure (cdr table))
        )
    )
  )
  )

#! Compare E-Closure elements to make sure it doesn't exist in table
(define compare-lists
  (lambda (l1 l2)
    (equal? (sort l1 <) (sort l2 <))
    )
  )
    
         
#! Adds E-Closure to the table and the Mark Associated with it
(define build-table
  (lambda (closure table)
    (cons (cons (+ 1 (length table)) (list closure)) table)
    )
  )
           
; #! Converts a Number into a Symbol
; (define number->symbol
;   (lambda (num)
;     (string->symbol(number->string num))
;   )
;  )
;#! Converst list of the states into a Symbol
; (define convert-list-to-symbol
;   (lambda (l)
;     (string->symbol (foldr (lambda (item string)
;              (string-append string (symbol->string item))
;              )
;            "" l)
;     )
;   )
;  )
   
#! (equal? (sort '(3 2 1 4 5) <) (sort '(2 1 3 4 5) <))

#! -----------------------------------------------------------------------------
#! -----------------------------------------------------------------------------
#! --------------------  END NFA to DFA CONVERSION        --------------------
#! -----------------------------------------------------------------------------
#! -----------------------------------------------------------------------------


#! -----------------------------------------------------------------------------
#! -----------------------------------------------------------------------------
#! --------------------       BEGIN DFA PRINTING            --------------------
#! -----------------------------------------------------------------------------
#! -----------------------------------------------------------------------------

#! Construcs a dictionary for mark replacement
;takes in dfa returns list of pairs ( ((e-closure) new-mark) ... )

(define final-dfa
  (lambda (file)
    (let ([dfa (start-conversion file)])
    (let ([fixed_dfa (append (take dfa 4) (check-dfa (cddddr dfa)))])
      ;fixed_dfa
      (let ([set_dict (build-set-dict (cddddr fixed_dfa) '() 1)])
        (let ([final-dfa (print-transitions (cddddr fixed_dfa) set_dict)])
        (display (string-append "\nInitial State: " (number->string (cadar fixed_dfa))))
        (print-final-states (cadadr fixed_dfa) set_dict)
        (print-alpha (cadddr fixed_dfa))
        (print-table final-dfa)  
          
;        ;;print the final table -- use final dfa
;        ;;use item from print transitions to populate final table
;       ; )
     )
    )
      )
    )
  )
  )

#! Prints the DFA table
(define print-table
  (lambda (dfa)
    dfa)
  )

  
#! Eliminates empty lists in dfa
(define check-dfa
  (lambda (dfa)
    (foldr (lambda (l final)
             (if(empty? (car l))
                final
                (cons l final)
                )
             ) '() dfa
           )
    )
  )

  #! Print Final States
  (define print-final-states
    (lambda (final_states set_dict)
      (display (string-append "\nFinal States: " (list-to-string (sort (remove-duplicates (foldr (lambda (state final) ;;state checking, final = final list of marks with 
               (append (check-dict state set_dict) final)
               ) '() final_states
                 )) <))))
      )
    )
  
#! Prints the alphabet of the dfa
  (define print-alpha
    (lambda (alpha_list)
      (display (string-append "\nStates: " 
                              (foldr (lambda (alpha str)
                                       (string-append str "   " (symbol->string alpha))
                                       ) "" (reverse (cadr alpha_list))
                                         )
                              )
               )
      )
    )

#! Checks if states exist in the eclosure values of the dicionary and returns the mark associated with them
  (define check-dict
    (lambda (item set_dict)
      (if (empty? set_dict)
          '()
          (if (member item (caar set_dict))
              (cons (cadar set_dict) (check-dict item (cdr set_dict)))
              (check-dict item (cdr set_dict))
              )
          )
      )
    )
             
          
          
  
  
 #! Print NFA to DFA Transitions
(define print-transitions
  (lambda (dfa set_dict)
    (map (lambda (line)
        (print-mark line set_dict) ;;will have to loop on items after that for each move in alpha
           (map (lambda (move)
                  (if (empty? (cadadr move))
                      (display "")
                      (print-full line move set_dict)
                      )
            ) (cadr line))
           (convert-line line set_dict)
           ;create a converted line that will be returned to final-dfa that will then be used to create the final table
           ) dfa )
    )
  )

#! Converts the mark line from eclosure/nfa states to proper mark/state notation
(define convert-line
  (lambda (line set_dict)
    (cons (input-mark (list (car line)) set_dict) 
         (list (map (lambda (l)
                      (if (empty? (caadr l))
                          (cons (car l) 0)
                          (cons (car l) (input-mark (list (caadr l)) set_dict))
                          )
                      ) (cadr line)
                   )
          ))
    )
  )

#! prints lines for moves and eclosures
(define print-full
  (lambda (line move set_dict)
    (print-move (car line) (car move) (cadadr move))
    (display "\n")
    (print-eclosure (cadadr move) (caadr move) (input-mark (list (caadr move)) set_dict))
    (display "\n")
    )
  )


;
;(define subst
;  (lambda (line sect_dic)
;    dfa ;will need to substitute all sect_dict values into this. then print-transitions will return the final dfa - then complete printer for final dfa
;    )
;  )


#! Prints Mark 'x': statement
(define print-mark
  (lambda (dfa set_dict)
    (display (string-append "\nMark " (number->string (input-mark dfa set_dict)) "\n"))
    )
  )
#! Prints E-closure -- alpha --> move line
(define print-move
  (lambda (start alpha move)
    (if (empty? move)
        (display "")
        (display (string-append (list-to-string start) (print-letter alpha) (list-to-string move)))
        )
    )
  )

#! Prints E-closure = e-closure -> mark
(define print-eclosure
  (lambda (move eclosure id)
    (if (empty? move)
        (display "")
        (display (string-append "E-Closure" (list-to-string move) " = " (list-to-string eclosure) " = " (number->string id)))
    )
  )
  )

#! Converts a list into a string  
(define list-to-string
  (lambda (l)
  (string-append (foldr (lambda (num str)
           (string-append str (number->string num) " ")
            ) "{ " (reverse l)) "}"
         )
    )
  )

#! Prints -- alpha -- >
(define print-letter
  (lambda (alpha)
    (string-append (string-append " --" (symbol->string alpha)) "--> ")
    )
  )

 #! Gives the mark of the input
(define input-mark
  (lambda (dfa set_dict)
    (if(compare-lists (car dfa) (caar set_dict))
       (cadar set_dict)
       (input-mark dfa (cdr set_dict))
       )
    )
  )

#! Builds to set_dictionary from the dfa
(define build-set-dict
  (lambda (dfa set num)
    (if (empty? dfa)
        set
        (if(empty? (caar dfa))
           (build-set-dict (cdr dfa) set (+ 1 num))
           (cons (list (caar dfa) num) (build-set-dict (cdr dfa) set (+ 1 num)))
        )
    )
    )
  )














#! -----------------------------------------------------------------------------
#! -----------------------------------------------------------------------------
#! --------------------         END DFA PRINTING            --------------------
#! -----------------------------------------------------------------------------
#! -----------------------------------------------------------------------------



   #!  (trace strings-to-list)
 #! (parser "/home/mteahan/Programming/EECS_665/Project1/test.txt")
 ;(e-closure (parser "/home/mteahan/Programming/EECS_665/Project1/test.txt") '(1))
;(mark (parser "/home/mteahan/Programming/EECS_665/Project1/test.txt") '(2 3 9))
;  (get-moves '(1 2 6) (parser "/home/mteahan/Programming/EECS_665/Project1/test.txt") 'a )
;(moves '(1 2 6) (parser "/home/mteahan/Programming/EECS_665/Project1/test.txt") '() '())
; (add-marks-to-dict '((b ((4 8 9 11) (4))) (a ((5 6 7 11) (4)))) '((b (3 9 10 11)) (a (4 8 90 11))))
;(cadr (assoc '9 (parser "/home/mteahan/Programming/EECS_665/Project1/test.txt")))
;(start-conversion "/home/mteahan/Programming/EECS_665/Project1/test.txt")
;(build-set-dict '(((1 2 5) ((a ((3) (3))) (b ((6) (6)))))
;  ((3) ((a (() ())) (b ((4 8 9 11) (4)))))
;  ((6) ((a ((7 8 9 11) (7))) (b (() ()))))
;  (() ((a (() ())) (b (() ()))))
;  ((4 8 9 11) ((a ((9 10 11) (10))) (b (() ()))))
;  ((7 8 9 11) ((a ((9 10 11) (10))) (b (() ()))))
;  ((9 10 11) ((a ((9 10 11) (10))) (b (() ()))))) '() 1)

;(print-mark '((1 2 5) ((a ((3) (3))) (b ((6) (6))))) '(((1 2 5) 1) ((3) 2) ((6) 3) ((4 8 9 11) 5) ((7 8 9 11) 6) ((9 10 11) 7)))
;(list-to-string '(1 2 3 4))
;
;(print-transitions (check-dfa '(((1 2 5) ((a ((3) (3))) (b ((6) (6)))))
;  ((3) ((a (() ())) (b ((4 8 9 11) (4)))))
;  ((6) ((a ((7 8 9 11) (7))) (b (() ()))))
;  (() ((a (() ())) (b (() ()))))
;  ((4 8 9 11) ((a ((9 10 11) (10))) (b (() ()))))
;  ((7 8 9 11) ((a ((9 10 11) (10))) (b (() ()))))
;  ((9 10 11) ((a ((9 10 11) (10))) (b (() ()))))))
;'(((1 2 5) 1) ((3) 2) ((6) 3) ((4 8 9 11) 5) ((7 8 9 11) 6) ((9 10 11) 7)))
;
;(check-dfa '(((1 2 5) ((a ((3) (3))) (b ((6) (6)))))
;  ((3) ((a (() ())) (b ((4 8 9 11) (4)))))
;  ((6) ((a ((7 8 9 11) (7))) (b (() ()))))
;  (() ((a (() ())) (b (() ()))))
;  ((4 8 9 11) ((a ((9 10 11) (10))) (b (() ()))))
;  ((7 8 9 11) ((a ((9 10 11) (10))) (b (() ()))))
;  ((9 10 11) ((a ((9 10 11) (10))) (b (() ()))))))


;(print-final-states '( 1 9 3) '(((1 2 5) 1) ((3) 2) ((6) 3) ((4 8 9 11) 5) ((7 8 9 11) 6) ((9 10 11) 7)))

(final-dfa "/home/mteahan/Programming/EECS_665/Project1/test.txt")
